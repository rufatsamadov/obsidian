Powershell ISE=Powershell integrated scripting env or Powershell easy
![[Pasted image 20241002093237.png]]
The command names are changing by the time(version) that's why it is important to know which version of powershell you are using as a hacker
gci=Get-ChildItem:
![[Pasted image 20241002094452.png]]
**Variables:**
![[Pasted image 20241002094824.png]]![[Pasted image 20241002094929.png]]
**The logic of keylogger is based on these stuff:**
![[Pasted image 20241002095214.png]]
***


```
`1.Objectives In this lab, the student will gain an understanding of the PowerShell Variables, User Input, and Console Output. 1.1. Tasks 1. Working With Variables: If you want to query the type of data a variable contains, you can do so with the Get-Member cmdlet. Get-Member also displays the variable's properties and methods. For example, variables of the System.String type have the ToUpper() method, which converts the content of the variable to uppercase. $server.ToUpper() LOCALHOST 2. To create a new variable, use an assignment statement to assign a value to the variable. You don't have to declare the variable before using it. The default value of all variables is $null $MyVariable = 1, 2, 3 $Path = "C:\Windows\System32" 3. Variables are useful for storing the results of commands. For example: $Processes = Get-Process $Today = (Get-Date).DateTime To change the value of a variable, assign a new value to the variable. LAB 2.1 3 1.2. Casting 1 To use cast notation, enter a type name, enclosed in brackets, before the variable name (on the left side of the assignment statement). # If no casting the number will be concatenated instead of multiplied
PS> [int]$num = read-host "Enter any number:" Enter any number: 1024 PS> $num = $num * 10 
PS> $num 10240 2. Using Variables in Commands and Expressions To use a variable in a command or expression, type the variable name, preceded by the dollar ($) sign. 
PS> $var = 'Hello' PS> $var = 'The content of the variable is $var' 
PS> $var The content of the variable is $var 3. The single quotes prevent the $ sign from being interpreted as the start of a variable name. 
PS> $var = 'Hello' PS> $var="Variable contains $var" 
PS> $var Variable contains Hello LAB 2.1 4 4. The backtick  causes Powershell to ignore the meaning of the following special character, for example: 
PS> $var = 'Hello' 
PS> $var="Variable $var contains $var" 
PS> $var The variable $var contains Hello 5. It can also be used to give special meaning to certain characters (equivalent to \ in C and Java, for example \n, \t...). 
PS> $computername = 'localhost' 
PS> $phrase = "`$computernamencontainsn$computername" 
PS> $phrase $computername contains localhost 6. It is possible to create a list type variable, separating the values of the list with commas: 
PS> $computers = 'server', 'localhost', 'server_2' 
PS> $computers server localhost server_2 LAB 2.1 5 7. List elements can be accessed by index number. Lists are numbered from zero: 
PS> $computers[0] server 
PS> $computers.count 3 8. It is also possible to iterate over a list using the Foreach-Object cmdlet. These two commands do the same thing: $computers = $computers.tolower() $computers = $computers | ForEach-Object {$_.tolower()}`
```
***
**LAB2.2**
![[Pasted image 20241002113147.png]]
# Common Information Model

- Article
- 01/08/2021
- 5 contributors

Feedback

The Common Information Model (CIM) is an extensible, object-oriented data model that contains information about different parts of an enterprise. The [CIM](https://www.dmtf.org/standards/cim) is a cross-platform standard maintained by the Distributed Management Task Force ([DMTF](https://www.dmtf.org/)). Through WMI, a developer can use the CIM to create classes that represent hard disk drives, applications, network routers, or even user-defined technologies, such as a networked air conditioner. By viewing and making changes to a CIM class, a manager can control different aspects of the enterprise. For example, a manager could query a CIM class instance representing a desktop workstation. The manager could then run a script to modify the CIM workstation instance. WMI would translate any change to the workstation CIM class instance into a change to the actual workstation.

The CIM is a language-independent programming model that uses object-oriented techniques to describe an enterprise. Using three levels of parent/child inheritance, the CIM can describe both general and specific aspects of an enterprise. The CIM also uses a technique called "association" to link different parts of the enterprise model together, and uses schemas to distinguish different management environments.

The CIM is designed to present a consistent view of logical and physical objects in a management environment. The CIM represents managed objects using an object-oriented construct called a "class." Like a C++ or COM class, a CIM class can include properties to describe data and methods to describe behavior. Like a set of COM classes, the CIM is not tied to any platform. However, WMI includes an extension to the CIM that describes the Microsoft Windows operating system platforms.

The CIM defines three levels of classes:

- Core
    
    Core classes represent managed objects that apply to all areas of management. These classes provide a basic vocabulary for analyzing and describing managed systems. The [**__Parameters**](https://learn.microsoft.com/en-us/windows/win32/wmisdk/--parameters) and [**__SystemSecurity**](https://learn.microsoft.com/en-us/windows/win32/wmisdk/--systemsecurity) classes are examples of core classes.
    
- Common
    
    Common classes represent managed objects that apply to specific management areas. However, common classes are independent from a particular implementation or technology. Common classes are an extension of the core classes. The [**CIM_UnitaryComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/cim-unitarycomputersystem) class is an example of a common class.
    
- Extended
    
    Extended classes represent managed objects that are technology-specific additions to the common classes. An extended class typically applies to a specific platform, such as UNIX or the Microsoft Win32 environment. The [**Win32_ComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystem) class is an example of an extended class.
    

A developer can derive a class from another class. A derived class represents a special case of the parent class, and inherits all of the properties and methods of the parent. For example, [**Win32_ComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystem) inherits from [**CIM_UnitaryComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/cim-unitarycomputersystem). Inheritance relationships may be determined using the system properties **__Derivation**, **__Dynasty**, and **__SuperClass**. The **__Derivation** system property is an array of strings listing the entire chain of inheritance up to and including the root class, which is also included in **__Dynasty**. The **__SuperClass** system property shows the immediate parent of the current class.

WMI also supports associations. An association is a relationship between two or more different WMI classes. For example, a running workstation usually has a processor. The WMI association class [Win32_ComputerSystemProcessor](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystemprocessor) associates the workstation class [**Win32_ComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystem) with the processor class [**Win32_Processor**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-processor). However, an association class does not have to tie two dependent classes together. In fact, the primary purpose of an association class is to show relationships between classes that are not necessarily dependent on each other. For more information, see [Declaring an Association Class](https://learn.microsoft.com/en-us/windows/win32/wmisdk/declaring-an-association-class).

Finally, WMI supports the concept of schemas. In the context of WMI, a schema is a group of classes that describe a particular management environment. The Microsoft Windows Software Development Kit (SDK) uses two schemas: the CIM schema and the Win32 schema. The CIM schema class names begin with [CIM_](https://learn.microsoft.com/en-us/windows/win32/wmisdk/cimclas), and the Win32 schema class names begin with [**Win32_**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-provider). The CIM schema contains the definitions for the core and common classes, while the Win32 schema contains the definitions for the extended classes that are common to the Win32 environment. However, a third-party vendor can create their own schemas to describe vendor-specific requirements. Because schemas are designed to be infinitely extensible, a developer can always add new classes to describe new managed objects in an existing environment. For simplicity, however, most vendors choose to create schemas that inherit properties from the CIM or Win32 schemas.
***
```
1. Objectives In this lab, the student will gain an understanding of the PowerShell Basic Scripting. 1.1. Execution Policy You can manage Windows PowerShell script execution on computers by adjusting the execution policy. The default policy varies by operating system version. To check the current setting, use the Get-ExecutionPolicy cmdlet. The choices for the execution policy include: Restricted. Running scripts is prohibited. AllSigned. Only digitally signed scripts are permitted to run. RemoteSigned. Downloaded scripts can only be executed if they have a digital signature. Unrestricted. Any script can run, but unsigned downloaded scripts will trigger a confirmation prompt. Bypass. All scripts execute without any prompts. Configuring the script execution policy creates a safeguard against unintended execution of untrusted scripts. However, it is important to note that the execution policy can always be bypassed. Use the Set-ExecutionPolicy cmdlet to set the execution policy on a computer. Managing this across multiple computers can be challenging. Instead, use the Group Policy setting under Computer Configuration\Policies\Administrative Templates\Windows Components\Windows PowerShell\Turn on Script Execution to override local settings. You can override the execution policy for an individual Windows PowerShell instance. This setting is useful if company policy requires the execution policy to be set as Restricted, but you still must run scripts occasionally. To override the execution policy, run PowerShell.exe with the -ExecutionPolicy parameter. LAB 2.2 3 Powershell.exe -ExecutionPolicy ByPass Scripts modified from the internet retain the attributes marking them as downloaded files. To clear this status, use the Unblock-File cmdlet. 1.2. Basic Scripting PowerShell scripts let you save commands for easier later use. Just write your commands in a text file with the .ps1 extension. Scripts are useful for complex tasks that would be cumbersome in a single command. While possible, long PowerShell commands are hard to manage; scripts simplify editing and comprehension. One repetitive task ideal for PowerShell is reporting. You can create scripts to generate text or HTML reports, like available disk space on servers or mail flow statistics in Exchange. Scripts can include constructs like ForEach, If, and Switch, which are rarely used in single commands, to process objects and make decisions. For instance, this command lists attached fixed disks with their free space, total size, and free space percentage: Get-CimInstance Win32_logicaldisk ` -filter "drivetype=3" | Sort-Object - Property DeviceID | format-table -Property DeviceID, @{n='FreeSpace(MB)';e={$_.FreeSpace / 1MB -as [int]}}, @{n='Size(GB)';e={$_.Size / 1GB -as [int]}}, @{n='%Free';e={$_.FreeSpace / $_.Size * 100 -as [int]}} LAB 2.2 4 At the end of the first line the backtick ` is used to indicate that the command has not finished yet. In the rest of the lines, this job is done by vertical bars and commas. This way it is easier to read. By copying these lines of code and saving them to a text file called Get-DiskInventory.ps1, a script will be created. Parameterization Scripts can be parameterized, that is, parameters can be created that can be specified at the time the script is executed. For example, in the script of the previous example it is possible to return parameters the name of the computer and the type of unit. The parameterized script would look like this: param( $DriveType = 3 ) Get-CimInstance Win32_logicaldisk ` -filter "drivetype=$DriveType" | Sort-Object-Property DeviceID | format-table -Property DeviceID, @{n='FreeSpace(MB)';e={$_.FreeSpace / 1MB -as [int]}}, @{n='Size(GB)';e={$_.Size / 1GB -as [int]}}, @{n='%Free';e={$_.FreeSpace / $_.Size * 100 -as [int]}} Optionally, each parameter can be specified with a default value, as seen in the example above. Parameters are positional by default. If the parameter names aren't specified, then the parameter values are passed to the parameters in order. If you don't put a Param() block in your script, you can still pass data into the script by using unnamed parameters. The values that are provided after the script name are available inside the script in the $args array. LAB 2.2 5 1.3. Run the script To run the script, type its name in the console. If it's in a different directory, use the full path to the file. If it doesn't run, adjust the execution policy with the SetExecutionPolicy cmdlet as administrator. This policy is a safety measure, preventing unintended actions. You can set it at different levels like the local computer, current user, or a specific session, and also via Group Policy for both computers and users. For more details, refer to the cmdlet help. . ./Get-DiskInventory.ps1 To run a Windows PowerShell script at the Windows PowerShell prompt, you can use the following methods:  Enter the full path to the script; for example, C:\Scripts\MyScript.ps1.  Enter a relative path to the script; for example, \Scripts\MyScript.ps1.  Reference the current directory; for example, .\MyScript.ps1. LAB 2.2 6 1.4. Script Documentation Scripts can be documented in such a way that they provide help similar to that provided by Powershell. The documented script would look like this: <# .SYNOPSIS Get-DiskInventory gets logical disk information for one or more computers. .DESCRIPTION Get-DiskInventory uses CIM to query the instances Win32_LogicalDisk from one or more computers. Display for each disk the drive letter, free space, total space, and percentage of free space. .PARAMETER DriveType The type of unit to query. View the Win32_LogicalDisk documentation for more information. 3 indicates a fixed disk, and is the default. .EXAMPLE Get-DiskInventory -DriveType 3 #> param( $DriveType = 3 ) Get-CimInstance -Class Win32_logicaldisk ` -filter "drivetype=$DriveType" | Sort-Object-Property DeviceID | Select-Object-Property DeviceID, @{n='FreeSpace(MB)';e={$_.FreeSpace / 1MB -as [int]}}, @{n='Size(GB)';e={$_.Size / 1GB -as [int]}}, @{n='%Free';e={$_.FreeSpace / $_.Size * 100 -as [int]}} LAB 2.2 7 Comments can be indicated by placing a # symbol at the beginning of each comment line, or using <# #> for multiple consecutive lines. Additionally, a minor modification was made to the script: Select-Object is used in place of the Format-Table cmdlet to avoid generating a formatted table as output. With Select-Object, the script's final output is an object, allowing end users to chain it with other commands via the pipeline. 1.5. Loops While there are some simple scripts that use only simple Windows PowerShell commands, most scripts use scripting constructs to perform more complex actions. You can use the ForEach construct to process all of the objects in an array. You can use If..Else and Switch constructs to make decisions in your scripts. Finally, there are less common looping constructs such as For, While, and Do..While loops that can be used when appropriate. ForEach When you perform piping, the commands in the pipeline are applied to each object. In some cases, you might need to use the ForEach-Object cmdlet to process the data in the pipeline. When you store data in an array, the ForEach construct allows you to process each item in the array. The ForEach construct uses the following syntax: ForEach ($user in $users) { Set-ADUser $user -Department "Marketing" } LAB 2.2 8 In scripting, the ForEach construct is widely utilized to handle items within an array. Its simplicity lies in the fact that it does not require knowledge of the exact number of items to be processed. Parallel performance PowerShell 7 introduced the -Parallel parameter to the ForEach-Object cmdlet, enabling simultaneous processing of multiple objects, which can enhance performance compared to a standard ForEach loop. $users | ForEach-Object -Parallel { Set-ADUser $user -Department "Marketing" } By default, the -Parallel parameter allows five items to be processed at a time. You can modify this to be larger or smaller by using the -ThrottleLimit parameter. For The For construct performs a series of loops similar to a ForEach construct. However, when using the For construct, you must define how many loops occur, which is useful when you want an action to be performed a specific number of times. For example, you could create a specific number of user accounts in a test environment. The For construct uses the following syntax: For($i=1; $i -le 10; $i++) { Write-Host "Creating User $i" } LAB 2.2 9 The For loop involves an initial state, a condition, and an action. In the previous example, the initial state is set to $i=1. The condition is $i -le 10, which determines if another iteration should occur. When this condition holds true, the loop runs again. After each iteration, the specified action, $i++, increments $i by 1. The code within the braces executes every time the loop runs. In the previous example, this loop runs 10 times. When handling an array of objects, ForEach is preferred since it eliminates the need to count items before processing. LAB 2.2 10 1.6. Other Loops There are other less common looping constructs that you can use. These looping constructs are Do..While, Do..Until, and While. All these looping constructs process a script block until a condition is met, but they vary in how they do it. Do..While The Do..While construct runs a script block until a specified condition isn't true. This construct guarantees that the script block is run at least once. The Do..While construct uses the following syntax: Do { Write-Host "Script block to process" } While ($answer -eq "go") Do..Until The Do..Until construct runs a script block until a specified condition is true. This construct guarantees that the script block is run at least once. The Do..Until construct uses the following syntax: Do { Write-Host "Script block to process" } Until ($answer -eq "stop") LAB 2.2 11 While The While construct runs a script block until a specified condition is false. While it's similar to the Do..While construct, it doesn't guarantee that the script block is run. The While construct uses the following syntax: While ($answer -eq "go") { Write-Host "Script block to process" } 1.7. Break & Continue Break and Continue are commands to alter loop behavior. Continue skips the current iteration, while Break halts the entire loop. They're often used for handling invalid data values. In this example, the use of Continue prevents modification of the Administrator user account in the list of users to be modified: ForEach ($user in $users) { If ($user.Name -eq "Administrator") {Continue} Write-Host "Modify user object" } In this instance, Break is utilized to terminate the loop once the maximum number of accounts has been updated: ForEach ($user in $users) { $number++ Write-Host "Modify User object $number" If ($number -ge $max) {Break} }
```
