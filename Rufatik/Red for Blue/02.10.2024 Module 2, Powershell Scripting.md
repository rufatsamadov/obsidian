Powershell ISE=Powershell integrated scripting env or Powershell easy
![[Pasted image 20241002093237.png]]
The command names are changing by the time(version) that's why it is important to know which version of powershell you are using as a hacker
gci=Get-ChildItem:
![[Pasted image 20241002094452.png]]
**Variables:**
![[Pasted image 20241002094824.png]]![[Pasted image 20241002094929.png]]
**The logic of keylogger is based on these stuff:**
![[Pasted image 20241002095214.png]]
***


```PowerShell
`1.Objectives In this lab, the student will gain an understanding of the PowerShell Variables, User Input, and Console Output. 1.1. Tasks 1. Working With Variables: If you want to query the type of data a variable contains, you can do so with the Get-Member cmdlet. Get-Member also displays the variable's properties and methods. For example, variables of the System.String type have the ToUpper() method, which converts the content of the variable to uppercase. $server.ToUpper() LOCALHOST 2. To create a new variable, use an assignment statement to assign a value to the variable. You don't have to declare the variable before using it. The default value of all variables is $null $MyVariable = 1, 2, 3 $Path = "C:\Windows\System32" 3. Variables are useful for storing the results of commands. For example: $Processes = Get-Process $Today = (Get-Date).DateTime To change the value of a variable, assign a new value to the variable. LAB 2.1 3 1.2. Casting 1 To use cast notation, enter a type name, enclosed in brackets, before the variable name (on the left side of the assignment statement). # If no casting the number will be concatenated instead of multiplied
PS> [int]$num = read-host "Enter any number:" Enter any number: 1024 PS> $num = $num * 10 
PS> $num 10240 2. Using Variables in Commands and Expressions To use a variable in a command or expression, type the variable name, preceded by the dollar ($) sign. 
PS> $var = 'Hello' PS> $var = 'The content of the variable is $var' 
PS> $var The content of the variable is $var 3. The single quotes prevent the $ sign from being interpreted as the start of a variable name. 
PS> $var = 'Hello' PS> $var="Variable contains $var" 
PS> $var Variable contains Hello LAB 2.1 4 4. The backtick  causes Powershell to ignore the meaning of the following special character, for example: 
PS> $var = 'Hello' 
PS> $var="Variable $var contains $var" 
PS> $var The variable $var contains Hello 5. It can also be used to give special meaning to certain characters (equivalent to \ in C and Java, for example \n, \t...). 
PS> $computername = 'localhost' 
PS> $phrase = "`$computernamencontainsn$computername" 
PS> $phrase $computername contains localhost 6. It is possible to create a list type variable, separating the values of the list with commas: 
PS> $computers = 'server', 'localhost', 'server_2' 
PS> $computers server localhost server_2 LAB 2.1 5 7. List elements can be accessed by index number. Lists are numbered from zero: 
PS> $computers[0] server 
PS> $computers.count 3 8. It is also possible to iterate over a list using the Foreach-Object cmdlet. These two commands do the same thing: $computers = $computers.tolower() $computers = $computers | ForEach-Object {$_.tolower()}`
```
***
**LAB2.2**
![[Pasted image 20241002113147.png]]
# Common Information Model

- Article
- 01/08/2021
- 5 contributors

Feedback

The Common Information Model (CIM) is an extensible, object-oriented data model that contains information about different parts of an enterprise. The [CIM](https://www.dmtf.org/standards/cim) is a cross-platform standard maintained by the Distributed Management Task Force ([DMTF](https://www.dmtf.org/)). Through WMI, a developer can use the CIM to create classes that represent hard disk drives, applications, network routers, or even user-defined technologies, such as a networked air conditioner. By viewing and making changes to a CIM class, a manager can control different aspects of the enterprise. For example, a manager could query a CIM class instance representing a desktop workstation. The manager could then run a script to modify the CIM workstation instance. WMI would translate any change to the workstation CIM class instance into a change to the actual workstation.

The CIM is a language-independent programming model that uses object-oriented techniques to describe an enterprise. Using three levels of parent/child inheritance, the CIM can describe both general and specific aspects of an enterprise. The CIM also uses a technique called "association" to link different parts of the enterprise model together, and uses schemas to distinguish different management environments.

The CIM is designed to present a consistent view of logical and physical objects in a management environment. The CIM represents managed objects using an object-oriented construct called a "class." Like a C++ or COM class, a CIM class can include properties to describe data and methods to describe behavior. Like a set of COM classes, the CIM is not tied to any platform. However, WMI includes an extension to the CIM that describes the Microsoft Windows operating system platforms.

The CIM defines three levels of classes:

- Core
    
    Core classes represent managed objects that apply to all areas of management. These classes provide a basic vocabulary for analyzing and describing managed systems. The [**__Parameters**](https://learn.microsoft.com/en-us/windows/win32/wmisdk/--parameters) and [**__SystemSecurity**](https://learn.microsoft.com/en-us/windows/win32/wmisdk/--systemsecurity) classes are examples of core classes.
    
- Common
    
    Common classes represent managed objects that apply to specific management areas. However, common classes are independent from a particular implementation or technology. Common classes are an extension of the core classes. The [**CIM_UnitaryComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/cim-unitarycomputersystem) class is an example of a common class.
    
- Extended
    
    Extended classes represent managed objects that are technology-specific additions to the common classes. An extended class typically applies to a specific platform, such as UNIX or the Microsoft Win32 environment. The [**Win32_ComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystem) class is an example of an extended class.
    

A developer can derive a class from another class. A derived class represents a special case of the parent class, and inherits all of the properties and methods of the parent. For example, [**Win32_ComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystem) inherits from [**CIM_UnitaryComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/cim-unitarycomputersystem). Inheritance relationships may be determined using the system properties **__Derivation**, **__Dynasty**, and **__SuperClass**. The **__Derivation** system property is an array of strings listing the entire chain of inheritance up to and including the root class, which is also included in **__Dynasty**. The **__SuperClass** system property shows the immediate parent of the current class.

WMI also supports associations. An association is a relationship between two or more different WMI classes. For example, a running workstation usually has a processor. The WMI association class [Win32_ComputerSystemProcessor](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystemprocessor) associates the workstation class [**Win32_ComputerSystem**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-computersystem) with the processor class [**Win32_Processor**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-processor). However, an association class does not have to tie two dependent classes together. In fact, the primary purpose of an association class is to show relationships between classes that are not necessarily dependent on each other. For more information, see [Declaring an Association Class](https://learn.microsoft.com/en-us/windows/win32/wmisdk/declaring-an-association-class).

Finally, WMI supports the concept of schemas. In the context of WMI, a schema is a group of classes that describe a particular management environment. The Microsoft Windows Software Development Kit (SDK) uses two schemas: the CIM schema and the Win32 schema. The CIM schema class names begin with [CIM_](https://learn.microsoft.com/en-us/windows/win32/wmisdk/cimclas), and the Win32 schema class names begin with [**Win32_**](https://learn.microsoft.com/en-us/windows/desktop/CIMWin32Prov/win32-provider). The CIM schema contains the definitions for the core and common classes, while the Win32 schema contains the definitions for the extended classes that are common to the Win32 environment. However, a third-party vendor can create their own schemas to describe vendor-specific requirements. Because schemas are designed to be infinitely extensible, a developer can always add new classes to describe new managed objects in an existing environment. For simplicity, however, most vendors choose to create schemas that inherit properties from the CIM or Win32 schemas.
